# 🧶 다중 포인터와 다차원 배열

C++에서는 포인터를 **여러 번 중첩**해서 사용하는 **다중 포인터**가 존재하며,  
2차원 배열은 포인터와 함께 사용될 때 자주 혼동되곤 합니다.  
이 파일에서는 **다중 포인터의 구조**, **2차원 배열의 메모리 구조**,  
그리고 `int**`, `int (*)[N]`, `int arr[][N]` 등의 차이를 구분합니다.

---

## 📌 다중 포인터란?

```cpp
int x = 10;
int* p = &x;
int** pp = &p;
```

- `int* p`: 정수형 변수 `x`의 주소
- `int** pp`: 포인터 `p`의 주소

```cpp
std::cout << x << std::endl;     // 10
std::cout << *p << std::endl;    // 10
std::cout << **pp << std::endl;  // 10
```

---

## 🧠 다중 포인터 구조 시각화

```
x   = 10
p   -> x
pp  -> p

**pp == *(*pp) == x
```

---

## 💡 2차원 배열 vs 포인터 배열 vs 포인터의 포인터

| 선언 | 의미 | 형태 |
|------|------|------|
| `int arr[2][3];` | 2행 3열 배열 | 고정 크기 2차원 배열 |
| `int* arr[2];`   | 포인터 2개짜리 배열 | 각 포인터가 배열을 가리킴 |
| `int** p;`       | 포인터를 가리키는 포인터 | 완전히 동적 구조 |

---

## 💡 예제: 2차원 배열 선언

```cpp
int arr[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

std::cout << arr[0][1];  // 2
```

- 메모리는 연속: `arr[0][0] arr[0][1] arr[0][2] arr[1][0] ...`

---

## 💡 예제: 포인터로 2차원 배열 접근

```cpp
int arr[2][3] = {{1,2,3},{4,5,6}};
int (*p)[3] = arr;

std::cout << p[1][2];  // 6
```

- `int (*p)[3]`은 "3개의 int를 가진 배열을 가리키는 포인터"
- `p + 1`은 두 번째 행의 시작 주소

---

## 💡 예제: 포인터 배열

```cpp
int r1[3] = {1,2,3};
int r2[3] = {4,5,6};
int* parr[2] = {r1, r2};

std::cout << parr[1][2];  // 6
```

- `parr`은 포인터 2개를 저장하는 배열
- 각 포인터는 1차원 배열을 가리킴 → 사실상 2차원처럼 동작

---

## ⚠️ 주의사항 요약

| 상황 | 잘못된 가정 | 정답 |
|------|--------------|------|
| `int** p`가 `int arr[2][3]`을 가리킴? | ❌ | `int**`는 포인터 배열과 구조가 다름 |
| 배열은 연속된 메모리? | ✅ | `arr[2][3]`은 6개 `int`가 연속 |
| 포인터 배열과 다차원 배열은 같음? | ❌ | 저장 구조가 완전히 다름 |

---

## ✅ 정리

- `int**`는 완전히 동적이고 유연하지만, 다차원 배열과 구조가 다름
- 2차원 배열은 `int arr[2][3]` → 연속 메모리 블록
- 포인터 배열은 `int* arr[2]` → 각각 다른 배열을 가리킴
- `int (*p)[3]`은 2차원 배열을 포인터로 접근할 때 가장 정확한 표현
