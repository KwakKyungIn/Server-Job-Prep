# ⚙️ 포인터 기본 정리

> 강의에서 배웠던 포인터 관련 개념을 정리하는 부분입니다.

---
## 1. 🎯 포인터 기초

**포인터(pointer)** 는 메모리의 주소를 저장하는 변수입니다.  
C++에서 모든 변수는 메모리에 저장되며, 포인터를 통해 해당 주소에 직접 접근할 수 있습니다.

---

### 📌 기본 문법

```cpp
int a = 10;
int* ptr = &a;     // a의 주소를 ptr에 저장
```

| 요소 | 의미 |
|------|------|
| `int* ptr` | `int`형 변수의 주소를 담는 포인터 |
| `&a` | 변수 `a`의 주소 |
| `*ptr` | 포인터가 가리키는 주소의 실제 값 (역참조) |

---

### 💡 예제 코드

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 10;
    int* ptr = &a;

    cout << "a = " << a << endl;            // 10
    cout << "*ptr = " << *ptr << endl;      // 10
    cout << "ptr = " << ptr << endl;        // a의 주소
    cout << "&a = " << &a << endl;          // a의 주소 (같음)

    *ptr = 20;  // a의 값을 간접적으로 변경
    cout << "a = " << a << endl;            // 20

    return 0;
}
```

---

### ✅ 핵심 요약

- `*` : 포인터 선언 / 역참조
- `&` : 변수의 주소를 얻음
- 포인터는 **주소를 저장하고 조작**하는 데 사용됨

---

## 2. ⚙️ 포인터 연산

포인터는 정수형이 아니지만, **포인터 연산(산술)** 을 통해 **다음(혹은 이전) 메모리 주소**로 이동할 수 있습니다.

---

### 📌 기본 연산

```cpp
int arr[3] = {10, 20, 30};
int* ptr = arr;

cout << *ptr << endl;       // 10
cout << *(ptr + 1) << endl; // 20
cout << *(ptr + 2) << endl; // 30
```

> `ptr + 1` 은 다음 요소의 주소로 이동  
> 배열의 크기에 따라 `+1` 이 실제로는 `+4`, `+8` 바이트 차이일 수 있음 (타입 크기만큼 이동)

---

### 💡 예제 코드

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[3] = {10, 20, 30};
    int* ptr = arr;

    for (int i = 0; i < 3; i++) {
        cout << "ptr[" << i << "] = " << *(ptr + i) << endl;
    }

    return 0;
}
```

---

### ⚠️ 주의할 점

- 포인터 연산은 **배열에서만 안전하게 사용 가능**
- 배열의 경계를 벗어나면 **미정의 동작(UB)** 발생 가능
- 잘못된 포인터 연산은 **Segmentation Fault**로 이어질 수 있음

---

### ✅ 핵심 요약

| 연산 | 의미 |
|------|------|
| `ptr + n` | n번째 다음 주소로 이동 |
| `*(ptr + n)` | n번째 값에 접근 |
| `ptr++` | 다음 요소로 이동 |

---


## 3. 🧭 참조 (Reference) 기초

C++에서 **참조(reference)** 는 *기존 변수에 새로운 이름(alias)* 을 부여하는 기능입니다.  
→ 어셈블리 수준에서는 포인터와 유사하게 작동하며, 문법적으로는 **더 간단하고 안전하게 주소값을 다룰 수 있는 방식**입니다.

---

### 📌 기본 선언 방식

```cpp
타입명& 참조이름 = 기존변수;
```

- 선언 시 반드시 초기화해야 함 (null 참조 불가)
- 선언 이후 다른 변수로 참조 대상을 변경할 수 없음

---

### 💡 예제 코드

```cpp
#include <iostream>
using namespace std;

int main() {
    int number = 1;

    int* pointer = &number;     // 포인터 선언
    *pointer = 2;               // 포인터를 통해 number 값 변경

    int& reference = number;    // 참조 선언
    reference = 3;              // 참조를 통해 number 값 변경

    cout << "number: " << number << endl;  // 출력: 3
    return 0;
}
```

---

### 🧠 참조 vs 포인터 요약

| 항목 | 참조 (`&`) | 포인터 (`*`) |
|------|-------------|----------------|
| 선언 시 초기화 | 반드시 필요 | 선택 가능 (`nullptr` 허용) |
| null 참조 | ❌ 불가 | ⭕ 가능 (`nullptr`) |
| 참조 대상 변경 | ❌ 불가 | ⭕ 가능 |
| 간접 접근 방식 | `ref = 3;` | `*ptr = 3;` |
| 사용 용도 | 안전한 주소 전달 | 동적 할당, 배열 처리 등 |

---

### 🎯 사용 이유

> ✅ **값 전달처럼 문법은 간단하게**,  
> ✅ **주소 전달처럼 원본 데이터를 직접 변경 가능**  

즉, **"포인터의 간접 접근 기능"을 보다 안전하고 간단하게 구현**할 수 있는 도구입니다.  
**함수 인자 전달 시 주로 사용**되며, 구조체나 클래스에서 값 복사 없이 처리할 때 유용합니다.

---
