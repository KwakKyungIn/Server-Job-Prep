# 🧠 Chapter 11. 멀티 레벨 피드백 큐 (MLFQ)

멀티 레벨 피드백 큐(MLFQ)는 **반환 시간 최적화 + 응답 시간 최적화**라는 두 마리 토끼를 잡기 위한 고급 스케줄링 기법이다.  
이 장에서는 MLFQ의 설계 원칙과 개선 과정을 살펴본다.

---

## 📌 핵심 문제
> 실행 시간 예측 없이 짧은 작업을 먼저 처리하려면 어떻게 해야 하는가?

---

## ✅ MLFQ 기본 원칙

- 여러 개의 큐 존재 (우선순위에 따라 상위~하위 정렬)
- 프로세스는 처음엔 **최상위 큐**에서 시작
- **타임 슬라이스를 모두 소진**하면 → **아래 우선순위 큐로 강등**
- **CPU를 빨리 반환**하면 → **우선순위 유지**
- 주기적으로 모든 프로세스를 최상위 큐로 복귀시켜 **기아(starvation)** 방지

---

## 🔁 기본 규칙 요약

| 규칙 | 내용 |
|------|------|
| 규칙 1 | 우선순위 높은 큐 먼저 실행 |
| 규칙 2 | 같은 큐는 RR 방식 |
| 규칙 3 | 새로운 작업은 최상위 큐부터 시작 |
| 규칙 4 | 타임슬라이스 소진 시 우선순위 강등 |
| 규칙 5 | 모든 작업을 일정 주기로 최상위 큐로 리셋 |

---

## 🧠 개선 시도

| 시도 | 설명 |
|------|------|
| 시도 1 | 우선순위 조절 (작업이 CPU 독점 시 하향) |
| 시도 2 | 우선순위 상승 (대기 시간이 길면 다시 상향) |
| 시도 3 | 정밀한 시간 측정 (CPU 점유량 기반 조절) |

---

## 💡 MLFQ의 특징

- **적응형 스케줄러**: 실행 시간 정보를 알지 못해도 동작함
- **대화형(인터랙티브)** 작업에 유리
- **다양한 시스템에서 기본 스케줄러로 사용**됨 (BSD Unix, Windows NT 등)

---

## 🧱 요약
# 🧠 운영체제 개요 (OSTEP Chapter 5)

운영체제는 컴퓨터 자원을 사용자와 응용 프로그램이 쉽게, 안전하게, 효율적으로 사용할 수 있도록 **가상화(virtualization)** 기법을 제공한다. 이 장에서는 운영체제가 하는 주요 역할 4가지(CPU 가상화, 메모리 가상화, 병행성, 영속성)와 그 철학, 그리고 역사적 발전 과정을 살펴본다.

---

## ❓ 핵심 질문

> 시스템 자원을 어떻게 **가상화(virtualization)** 하여 **사용성과 효율성**을 모두 확보할 수 있을까?

---

## 🔍 상세 개념 정리

### 5.1 CPU 가상화

> **자원을 어떻게 가상화하는가?**

- 하나의 CPU를 여러 개의 가상 CPU처럼 만들어 프로그램이 **동시에 실행되는 것처럼** 보이게 한다.
- OS는 **타이머 인터럽트**, **CPU 스케줄링** 기법을 통해 이 illusion을 제공한다.

#### 💻 예제 코드 (`cpu.c`)
```c
while (1) {
    Spin(1);            // 1초 대기
    printf("%s\n", str);
}
```

#### 💡 실행 예시
```bash
./cpu A & ./cpu B & ./cpu C & ./cpu D &
# 동시에 실행되는 것처럼 보인다!
```

---

### 5.2 메모리 가상화

> **물리 메모리를 어떻게 독립적인 가상 메모리처럼 보이게 만들까?**

- 각 프로세스는 독립적인 **가상 주소 공간**을 가지며, 운영체제가 이를 **물리 메모리로 매핑**한다.
- 이를 통해 서로 간의 메모리 침범 없이 안정적인 실행이 가능하다.

#### 💻 예제 코드 (`mem.c`)
```c
int *p = malloc(sizeof(int));
*p = 0;
while (1) {
    *p += 1;
    printf("p: %d\n", *p);
}
```

#### 💡 실행 예시
```bash
./mem & ./mem &
# 같은 주소 (예: 0x200000)를 출력하지만, 실제로는 각기 다른 물리 메모리를 사용
```

---

### 5.3 병행성 (Concurrency)

> **올바르게 동작하는 병행 프로그램은 어떻게 작성할 수 있는가?**

- 여러 스레드가 공유 변수에 동시에 접근할 때 **경쟁 조건(Race Condition)**이 발생할 수 있다.
- **락(mutex)** 같은 동기화 기법으로 이를 제어해야 한다.

#### 💻 예제 코드 (`thread.c`)
```c
pthread_create(&p1, NULL, worker, NULL);
pthread_create(&p2, NULL, worker, NULL);
```

#### 💡 결과 예시
```bash
./thread 1000
# 기대값: 2000, 실제값: 예측 불가 → 병행성 이슈
```

---

### 5.4 영속성 (Persistence)

> **데이터를 영속적으로 저장하려면 어떻게 해야 하는가?**

- 휘발성 메모리를 보완하기 위해 **디스크와 파일 시스템**을 활용
- 운영체제는 파일 시스템을 통해 `open()`, `write()`, `close()` 등의 시스템 콜 제공

#### 💻 예제 코드 (`io.c`)
```c
int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
write(fd, "hello world\n", 13);
close(fd);
```

---

### 5.5 운영체제 설계 목표

| 🎯 목표 | 설명 |
|--------|------|
| 🔍 추상화 (Abstraction) | 복잡한 하드웨어를 쉽게 사용할 수 있도록 개념화 |
| ⚡ 성능 (Performance) | 오버헤드 최소화 |
| 🔒 보호 (Protection) | 프로세스 간 메모리 보호 |
| 🔁 신뢰성 (Reliability) | OS 오류가 전체 시스템 오류로 이어지지 않도록 |

---

### 5.6 운영체제의 역사

- **초기 운영체제**는 단순한 라이브러리 형태
- **멀티프로그래밍 시대**: 병행성, 메모리 보호, 인터럽트 관리 도입
- **Unix의 등장**: 단순하고 강력한 구조, C 언어 기반 → Linux로 진화
- **현대 운영체제**: PC, 모바일에서 Unix 계열이 주류 (macOS, Linux, Android 등)

---

## ✅ 요약

운영체제는 다음 네 가지 기능을 중심으로 설계된다:

- CPU 가상화
- 메모리 가상화
- 병행성
- 영속성

이러한 기능은 시스템을 **효율적이고 안정적으로** 운영하며, 사용자와 프로그램이 **편리하게 컴퓨터 자원**을 사용할 수 있도록 돕는다.

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』

- MLFQ는 **SJF의 반환 시간 최적화**와 **RR의 응답 시간 최적화**를 절충한 스케줄러
- CPU 사용 패턴을 관찰해 우선순위를 동적으로 조절
- 실세계에서 매우 널리 쓰이는 알고리즘

---

> 📚 출처: 『OSTEP Chapter 11 – 멀티 레벨 피드백 큐』
