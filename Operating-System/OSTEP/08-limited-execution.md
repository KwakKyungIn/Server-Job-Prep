# 🧠 Chapter 8. 제한적 직접 실행 원리

## 📌 핵심 질문
> 어떻게 운영체제가 **CPU 가상화**를 효율적이면서도 제어 가능하게 구현할 수 있을까?

---

## ✅ 8.1 기본 아이디어: 제한적 직접 실행 (Limited Direct Execution)

- 운영체제는 사용자 프로그램을 직접 CPU 위에서 실행시킴
- → **속도는 빠르지만**, **제어권 유지**가 필요함
- 하드웨어 + OS 협력이 필요

---

## ⚠️ 문제 1: 특권 명령어

- 일부 명령어는 **커널 모드에서만 실행 가능**
- 사용자 모드에서는 시스템 콜을 통해 커널에 요청해야 함

---

## ⚠️ 문제 2: 시스템 콜 처리

- 사용자 프로그램이 OS 기능을 요청하면 **트랩(trap)** 발생
- 커널 모드로 전환되어 처리 후 복귀
- 예: `read()`, `write()`, `open()`, `exit()`

---

## ⚠️ 문제 3: 프로세스 전환 (Context Switch)

### ✍️ 문맥 교환 시나리오

1. 현재 프로세스의 레지스터 저장
2. 다음 실행할 프로세스의 레지스터 복원
3. 커널 스택 전환
4. 트랩 복귀 → 새 프로세스 실행 시작

```asm
# switch(context *old, context *new)
movl %esp, 4(%eax)     # 현재 스택 포인터 저장
movl 28(%eax), %ebp    # 새 레지스터 복원
...
ret                    # 복귀
```

> `xv6`에서 사용하는 low-level switch 코드 예제

---

## ✅ 핵심 요약

| 항목 | 설명 |
|------|------|
| 직접 실행 | 사용자 프로그램은 CPU에서 직접 실행됨 |
| 특권 분리 | 사용자/커널 모드 구분 |
| 트랩 | 시스템 콜 시 커널 진입 |
| 인터럽트 | 강제 전환 시 커널 개입 |
| 문맥 교환 | 프로세스 전환 시 레지스터/스택 상태 저장 |

---

> 📚 출처: 『OSTEP Chapter 8 – 제한적 직접 실행』
