# 📁 파일 시스템 구현 (OSTEP Chapter 43)

> 이 장에서는 운영체제가 디스크 위에 실제 파일 시스템을 어떻게 설계하고 구현하는지를 다룬다.  
> 사용자에게는 단순한 파일처럼 보이지만, 내부적으로는 다양한 메타데이터와 블록 배치 전략이 존재한다.

---

## ❓ 핵심 질문

> 운영체제는 어떻게 디스크라는 단순한 블록 장치 위에  
> 사용자가 이해할 수 있는 고수준의 파일 시스템을 효과적으로 구현할 수 있을까?

---

## 🔍 상세 개념 정리

---

### 43.1 생각하는 방법

파일 시스템은 두 가지 관점을 고려해야 한다:

- **자료구조 관점**: 파일 메타데이터와 실제 데이터 저장 방식을 어떻게 설계할 것인가?
- **시스템 호출 관점**: `open()`, `read()`, `write()` 등 API 호출이 내부적으로 어떤 동작을 수행하는가?

운영체제는 이 두 관점을 모두 충족하도록 설계되어야 한다.  
파일 시스템은 **지속적인 저장(persistent storage)**이 핵심이며,  
단순한 메모리 기반 시스템보다 훨씬 더 많은 고려 사항이 필요하다.

---

### 43.2 전체 구성 (The Whole Picture)

운영체제가 디스크에 파일 시스템을 만들기 위해 사용하는 **기본 구성요소**는 다음과 같다:

#### 🔹 디스크 구역 구조

| 구역 | 설명 |
|------|------|
| 부트 블록 | 부트 로더 등 시스템 부팅용 코드 |
| 슈퍼블록 | 파일 시스템 전체 정보 (크기, inode 수 등) |
| inode 영역 | 파일 메타데이터 저장 공간 |
| 데이터 블록 | 실제 파일 데이터 저장 |

디스크 상에서의 배치는 일반적으로 다음과 같은 순서로 구성된다:

```
[ Boot | SuperBlock | inode 배열 | 데이터 블록 영역 ]
```

이러한 고정된 배치는 간단하고 빠른 파일 접근이 가능하게 한다.

#### 🔹 핵심 개념: inode

파일 시스템에서 **파일은 inode를 통해 식별**된다.  
inode는 파일의 메타데이터와 데이터 블록 위치를 포함하는 구조체이다.

파일명을 기반으로 inode를 찾고, inode를 통해 실제 데이터 블록에 접근하는 방식이다.

> 핵심: 사용자 = "파일 이름" ↔ 시스템 = "inode 번호"

---

### 43.3 파일 구성: 아이노드 (inode)

`inode`는 각 파일마다 존재하는 **메타데이터 저장 구조체**다.  
파일 이름은 inode에 저장되지 않고 디렉터리 항목에만 존재한다.

#### 📦 inode 구조

| 필드 | 설명 |
|------|------|
| 파일 타입 | 일반 파일 / 디렉토리 등 |
| 소유자 | UID, GID |
| 권한 | 읽기/쓰기/실행 비트 |
| 크기 | 바이트 단위 파일 크기 |
| 생성/수정/접근 시간 | 시간 정보 |
| 데이터 블록 포인터 | 실제 파일 내용의 위치 목록 |

#### 📌 블록 포인터 구성

간단한 inode 구현은 다음과 같은 포인터들을 포함할 수 있다:

- **직접 포인터 (Direct)**: 실제 데이터 블록 주소 (예: 12개)
- **단일 간접 포인터 (Single indirect)**: 한 블록이 여러 데이터 블록 주소를 보유
- **이중 간접 포인터 (Double indirect)**: 주소 블록을 가리키는 블록을 또 가리킴
- **삼중 간접 포인터 (Triple indirect)**: 거대한 파일도 지원 가능

이 구조를 통해 **작은 파일에는 빠른 접근**, **큰 파일에는 유연한 확장**을 제공할 수 있다.

---  
---

### 43.4 디렉터리 구조 (The Directory Structure)

디렉터리는 **파일 이름과 해당 파일의 inode 번호를 매핑**하는 특수한 파일이다.  
운영체제는 디렉터리를 통해 사용자 친화적인 이름으로 파일을 다룰 수 있도록 한다.

#### 🧱 디렉터리의 역할

- 디스크 상의 파일 이름 → inode 번호 변환
- 같은 이름을 가진 파일이 존재하지 않도록 강제
- 하위 디렉터리 생성 → 트리 구조 지원
- 파일 삭제 시 inode 해제 트리거 역할

#### 📦 디렉터리 엔트리 구조 (간단한 예)

| 필드 | 설명 |
|------|------|
| inode 번호 | 파일의 메타데이터 위치 식별자 |
| 파일 이름 | 가변 길이 혹은 고정 길이의 문자열 |

예시:
```
[ inode: 10 | name: "foo.txt" ]
[ inode: 11 | name: "bar.log" ]
```

#### 📍 중요한 점

- 파일 이름은 **inode 자체에 포함되지 않음**
- 하나의 inode가 여러 디렉터리 항목에 의해 참조될 수 있음 → 하드 링크(hard link)

---

### 43.5 빈 공간의 관리 (Managing Free Space)

디스크에는 삭제되거나 사용되지 않는 **빈 블록들**이 생긴다.  
효율적인 파일 시스템은 이 공간을 **추적하고 재사용**할 수 있어야 한다.

#### 📌 두 가지 주요 기술

| 기법 | 설명 |
|------|------|
| 비트맵 (Bitmap) | 각 블록마다 1비트로 사용 여부 표시 (`0 = free`, `1 = used`) |
| 자유 리스트 (Free List) | 사용 가능한 블록을 **연결 리스트**로 구성하여 관리 |

#### 🔍 비트맵 예시 (8 블록 디스크)

```
[1][0][1][1][0][0][1][0]  
=> 총 3개의 빈 블록 존재 (인덱스 1, 4, 5, 7)
```

- 비트맵은 **빠른 검색 및 압축이 가능**
- 단점: 메모리에 올릴 수 없을 정도로 커질 수 있음

#### 🔍 자유 리스트 예시

```c
struct free_block {
    int next;
};
```

- 각 빈 블록에 다음 빈 블록의 번호 저장
- 검색은 느리지만 구현이 단순

> 현실적인 시스템은 보통 **두 방식을 혼합**하거나 **여러 계층의 캐시**와 함께 사용한다.

---

### 43.6 실행 흐름: 읽기와 쓰기 (Reading and Writing)

운영체제가 `read()`, `write()` 같은 **시스템 호출**을 받으면,  
파일 시스템은 내부적으로 **여러 단계를 거쳐 디스크와 상호작용**하게 된다.

#### 📥 읽기 흐름 (read)

1. 사용자가 파일 이름을 지정해 `open()` 호출
2. 운영체제가 디렉터리를 검색하여 inode 번호 획득
3. 해당 inode의 **블록 포인터 목록 확인**
4. 블록 캐시 또는 디스크에서 데이터 블록 읽음
5. 버퍼에 복사하여 사용자 공간에 반환

#### 📤 쓰기 흐름 (write)

1. 기존 파일에 추가하거나 덮어쓰기 위해 `open()` + `write()` 호출
2. 필요한 블록이 없으면 **빈 블록 할당**
3. inode의 블록 포인터 업데이트
4. 데이터는 디스크 또는 버퍼에 기록됨
5. 메타데이터 수정 (크기, 수정 시간 등)

> 중요: **쓰기 순서**는 매우 중요  
> 메타데이터 → 데이터 → 블록 포인터를 **잘못된 순서로 업데이트하면 시스템 충돌 시 파일 손상 발생 가능**

#### 💡 해결책: 쓰기 순서 조절

- **데이터 먼저 쓰기**, 그다음 포인터, 마지막에 메타데이터
- 또는 **저널링(journaling)** 도입 → 트랜잭션처럼 처리
