# 🚦 세마포어 (OSTEP Chapter 34)

이 장에서는 병행성 문제를 해결하기 위한 또 다른 기본 동기화 도구인 **세마포어(semaphore)** 를 다룬다.  
세마포어는 **락과 컨디션 변수 모두의 기능을 결합한 형태**이며, 고전적 병행성 문제들에 자주 사용된다.

---

## ❓ 핵심 질문

> 락과 컨디션 변수로도 병행성 문제를 해결할 수 있지만, **더 간결하게, 하나의 추상화로** 해결할 수 있는 방법이 없을까?  
> 고전적 병행성 문제들은 어떤 방식으로 세마포어를 이용해 풀 수 있을까?

---

## 🔍 상세 개념 정리

---

### 34.1 세마포어: 정의

세마포어는 두 가지 기본 동작을 제공하는 간단한 데이터 타입이다.

| 연산 | 설명 |
|------|------|
| wait() | 값이 0보다 크면 감소하고 반환, 0이면 대기 |
| signal() | 값 증가, 대기 중인 쓰레드 깨움 |

Pthreads에서는 다음과 같은 API로 사용한다.

```c
sem_t s;
sem_init(&s, 0, initval);
sem_wait(&s);  // wait
sem_post(&s);  // signal
```

---

### 34.2 이진 세마포어(락)

초기 값이 1인 세마포어는 락으로 사용할 수 있다.

| 동작 | 세마포어 |
|------|----------|
| lock() | wait() |
| unlock() | signal() |

락과 마찬가지로, **임계 구역을 보호하는 데 사용**된다.

---

### 34.3 컨디션 변수로서의 세마포어

세마포어는 컨디션 변수처럼 **대기 및 깨우기 역할** 도 수행할 수 있다.

| 컨디션 변수 | 세마포어 |
|--------------|----------|
| wait() | wait() |
| signal() | signal() |

하지만 세마포어에는 락이 포함되지 않으므로, 락은 **별도로 명시적 관리**해야 한다.

---

### 34.4 생산자/소비자(유한 버퍼) 문제

세마포어를 사용해 생산자/소비자 문제를 해결할 수 있다.

#### 데이터 구조
```c
sem_t empty;
sem_t full;
pthread_mutex_t mutex;
```

#### 초기화
```c
sem_init(&empty, 0, MAX);
sem_init(&full, 0, 0);
pthread_mutex_init(&mutex, NULL);
```

#### 소비자 코드
```c
sem_wait(&full);
pthread_mutex_lock(&mutex);
// 버퍼에서 제거
pthread_mutex_unlock(&mutex);
sem_post(&empty);
```

#### 생산자 코드
```c
sem_wait(&empty);
pthread_mutex_lock(&mutex);
// 버퍼에 추가
pthread_mutex_unlock(&mutex);
sem_post(&full);
```

---

### 34.5 Reader-Writer 락

읽기 쓰레드는 동시에 여러 개 가능하지만, 쓰기 쓰레드는 단독으로 실행해야 하는 경우다.

세마포어를 이용해 다음과 같이 구현할 수 있다.

| 연산 | 동작 |
|------|------|
| read_lock() | 읽기 세마포어 증가 |
| read_unlock() | 읽기 세마포어 감소 |
| write_lock() | 읽기 세마포어가 0이 될 때까지 대기 |
| write_unlock() | 완료 후 다시 열어줌 |

구현 방법은 복잡하며 여러 가지 버전이 존재한다.

---

### 34.6 식사하는 철학자

철학자들은 식사하려면 **좌우 포크**를 동시에 잡아야 한다.

| 철학자 행동 | 세마포어 |
|--------------|----------|
| 포크 잡기 | wait() |
| 포크 놓기 | signal() |

단순히 두 포크를 각각 세마포어로 표현하여 deadlock 이 발생하지 않게 하려면 **전체 철학자 수보다 적은 수만 식사 허용** 같은 추가 전략이 필요하다.

---

### 34.7 세마포어 구현

세마포어는 일반적으로 다음 구성 요소로 구현된다.

| 구성 요소 | 설명 |
|-----------|------|
| 정수 값 | 현재 세마포어 값 |
| 대기 큐 | wait() 에 의해 대기 중인 쓰레드 목록 |

#### wait() 의 구현
- 값이 0보다 크면 감소하고 반환
- 0이면 대기 큐에 추가되고 **슬립(sleep)**

#### signal() 의 구현
- 대기 큐가 비어 있으면 값 증가
- 대기 큐에 쓰레드가 있으면 하나를 깨움

---

### 34.8 요약

세마포어는 병행 프로그램에서 **락 + 컨디션 변수** 역할을 모두 수행할 수 있는 강력한 도구다.

| 구성 요소 | 역할 |
|-----------|------|
| wait() | 자원 요청, 필요 시 대기 |
| signal() | 자원 반환, 대기 중인 쓰레드 깨움 |

세마포어는 여러 고전적 병행성 문제에서 사용되며, 각 문제의 요구사항에 따라 초기값과 사용 패턴이 달라진다.

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
