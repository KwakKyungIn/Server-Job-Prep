# 🔀 병행성: 개요 (OSTEP Chapter 29)

지금까지 배운 가상화는 CPU, 메모리 등을 가상의 자원처럼 보이게 하여 각 프로그램이 독립적으로 실행되는 환경을 제공했다.  
이번 장부터는 **여러 흐름이 동시에 실행되는 상황**, 즉 **병행성(concurrency)** 을 다룬다.  
병행성에서는 실행 흐름을 **쓰레드(thread)** 로 표현하며, 이 흐름들이 서로 간섭하지 않고 올바르게 동작하도록 관리해야 한다.

---

## ❓ 핵심 질문

> 하나의 프로세스 안에서 여러 실행 흐름이 동작할 때,  
> 그 흐름들이 서로 충돌하지 않고, 안정적으로 실행되려면 어떻게 해야 할까?

---

## 🔍 상세 개념 정리

### 29.1 쓰레드란 무엇인가?

#### 🧠 쓰레드와 프로세스 비교
| 항목 | 프로세스(Process) | 쓰레드(Thread) |
|------|------------------|----------------|
| 주소 공간 | 각자 독립적 | 공유 |
| 코드/데이터 | 독립적 | 공유 |
| 스택 | 독립적 | **각자 가짐** |
| 프로그램 카운터 | 독립적 | 독립적 |
| 레지스터 | 독립적 | 독립적 |

- 쓰레드는 같은 프로세스 내에서 **코드, 데이터, 힙** 을 공유
- 하지만 각각의 실행 흐름이므로 **독립적인 스택, 레지스터, PC** 를 가짐

#### 💡 쓰레드의 상태 저장
- 프로세스 제어 블록(PCB): 프로세스 상태 저장
- 쓰레드 제어 블록(TCB): 쓰레드 상태 저장
- → 문맥 교환(context switch) 시 레지스터만 교체하고 주소 공간은 그대로 사용

#### 🧑‍💻 스택 구성
| 구조 | 특징 |
|------|------|
| 단일 쓰레드 | 하나의 스택만 존재 |
| 멀티 쓰레드 | 각 쓰레드마다 스택이 존재 (쓰레드-로컬 저장소) |

→ 힙과 스택의 경계가 복잡해지지만, 일반적으로 문제 없음

---

### 29.2 쓰레드 생성 예제

#### ✅ 예제 코드 (`t0.c`)
```c
#include <stdio.h>
#include <pthread.h>
#include <assert.h>

void *mythread(void *arg) {
    printf("%s\n", (char *) arg);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p1, p2;
    printf("main: begin\n");
    assert(pthread_create(&p1, NULL, mythread, "A") == 0);
    assert(pthread_create(&p2, NULL, mythread, "B") == 0);
    assert(pthread_join(p1, NULL) == 0);
    assert(pthread_join(p2, NULL) == 0);
    printf("main: end\n");
    return 0;
}
```

#### 🔍 가능한 실행 결과 예시
| 시간 흐름 ↓ | Main | 쓰레드 1 | 쓰레드 2 |
|-------------|------|----------|----------|
| 시작 | main: begin | | |
| 쓰레드 생성 | 쓰레드 1 생성 | | |
| | 쓰레드 2 생성 | | |
| | | "A" 출력 |
| | | "B" 출력 |
| 종료 | main: end | | |

→ 실행 결과는 매번 다를 수 있음 (스케줄링 방식에 따라)

---

### 29.3 공유 데이터 문제

#### ⚠️ 문제 코드 (`t1.c`)
```c
static volatile int counter = 0;

void *mythread(void *arg) {
    for (int i = 0; i < 1e7; i++) {
        counter = counter + 1;
    }
    return NULL;
}
```

#### ❌ 기대 결과
- counter = 20,000,000

#### 😱 실제 결과
- 실행할 때마다 다름 (예: 19,321,102)

#### 원인
- `counter = counter + 1`이 실제로는 3개의 명령어로 실행됨:
```asm
mov counter, %eax   // counter 값 읽기
add $1, %eax        // 1 더하기
mov %eax, counter   // 다시 저장
```
→ 두 쓰레드가 중간에 끼어들면서 값이 꼬임

---

### 29.4 경쟁 조건 (Race Condition)

#### 🔍 문제 발생 시나리오
| 쓰레드 1 | 쓰레드 2 |
|----------|----------|
| counter 읽음 (50) | |
| | counter 읽음 (50) |
| 50 + 1 계산 | |
| | 50 + 1 계산 |
| 51 저장 | |
| | 51 저장 |

→ 총 2번 더했는데 결과는 51 → 잘못된 결과

#### 🛡️ 해결책
- **상호 배제(Mutual Exclusion)** 로 한 번에 하나의 쓰레드만 임계 영역 실행
- 임계 영역(Critical Section): 동시에 실행되면 안 되는 코드 블록

---

### 29.5 원자성(Atomicity) 개념

#### ✔️ 이상적 명령어 예시
```asm
memory-add counter, $1
```
→ 이런 명령어는 **한 번에 완료되므로 경쟁 조건이 없음**

#### ❌ 현실
- 일반 CPU는 이런 복합 연산을 하나의 명령어로 제공하지 않음
- 소프트웨어적으로 락(lock) 등으로 보호 필요

---

### 29.6 추가 문제: 대기(Synchronization)

#### 예시 상황
- 쓰레드 A가 초기화 끝날 때까지 쓰레드 B가 기다려야 함
- I/O 작업 완료까지 대기해야 함

#### 해결책
- 조건 변수(Condition Variable)
- 세마포어(Semaphore)
- 락 등 동기화 도구 사용

---

### 29.7 운영체제에서 병행성을 다루는 이유

#### 역사적 배경
- 운영체제는 최초의 병행 프로그램
- 커널 내부 자료구조(페이지 테이블, 파일 시스템 등)를 보호해야 했음

#### 현대적 의미
- 사용자 프로그램도 멀티쓰레드 사용 → OS가 안정적인 동기화 기능 제공 필요

---

## ✅ 요약

병행성은 여러 실행 흐름이 동시에 실행되면서 발생하는 **충돌 문제**를 어떻게 예방하느냐가 핵심이다.

| 용어 | 설명 |
|------|------|
| 쓰레드 | 독립적인 실행 흐름 (스택/레지스터 독립) |
| 임계 영역 | 공유 자원 접근 코드 |
| 경쟁 조건 | 실행 순서에 따라 결과가 달라지는 문제 |
| 상호 배제 | 한 번에 하나의 흐름만 임계 영역 실행 |
| 원자성 | 중간 상태 없이 한 번에 실행되는 성질 |

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
