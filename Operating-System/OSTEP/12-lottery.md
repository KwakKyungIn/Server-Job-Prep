# 🎰 스케줄링: 비례 배분 (OSTEP Chapter 12)

이번 장에서는 **비례 배분(Proportional Share)** 스케줄링, 특히 대표적인 기법인 **추첨 스케줄링(Lottery Scheduling)** 과 **보폭 스케줄링(Stride Scheduling)** 에 대해 배운다.  
이 스케줄링들은 반환 시간이나 응답 시간을 최소화하는 것이 아니라, **각 작업이 전체 CPU 자원 중에서 정해진 비율만큼을 받도록** 보장하는 것을 목표로 한다.

---

## ❓ 핵심 질문

> 어떻게 하면 각 작업에 대해 **지정된 CPU 비율만큼 정확하게 실행 시간**을 배정할 수 있을까?

---

## 🔍 상세 개념 정리

### 12.1 추첨권이 당신의 몫을 나타낸다

비례 배분의 핵심 아이디어는 **작업에게 "추첨권(ticket)"을 주는 것**이다.  
- A에게 75장의 추첨권, B에게 25장의 추첨권을 주면, A는 전체 CPU 시간의 75%, B는 25%를 받도록 설계한다.
- 스케줄러는 타임 슬라이스가 끝날 때마다 **전체 추첨권 중에서 무작위로 1장을 뽑고**, 해당 추첨권을 가진 작업을 실행한다.

#### 📌 개념 요약
- 각 작업은 자신이 소유한 추첨권 수만큼 **확률적으로** CPU를 얻는다.
- 충분한 시간 동안 반복하면, 실제 점유 시간은 추첨권 비율에 **수렴**한다.

#### 🎲 예시

- A: 75장, B: 25장 → 총 100장
- 랜덤 추첨 20회: 63, 85, 70, 39, 76, 17, 29, 41, 36, 39, 10, 99, 68, 83, 63, 62, 43, 0, 49, 49
- 결과: A가 16번, B가 4번 당첨됨 (A = 80%, B = 20%)

> **무작위성** 때문에 단기적으로는 편차가 생길 수 있지만, **장기적으로는 기대값에 수렴**

---

### 12.2 무작위 방식의 장점

추첨 스케줄링은 단순한 개념이지만, 여러 면에서 **전통적인 결정적 스케줄러보다 유리한 점**이 있다:

#### ✅ 장점 1: 예외 상황에 강함
- 결정적 알고리즘은 특정 패턴(예: LRU의 순차 접근)에 취약할 수 있다.
- 추첨 스케줄링은 **무작위 방식이기 때문에 편향되지 않음**

#### ✅ 장점 2: 상태 관리가 간단
- 사용한 CPU 시간 등 **과거 이력 관리가 불필요**
- 각 프로세스가 가진 **추첨권 수만 관리**하면 됨

#### ✅ 장점 3: 빠르고 효율적
- 난수 발생 → 리스트 순회만으로 당첨자 결정
- 가볍고 구현이 단순함

---

### 12.3 구현: 추첨 스케줄러 코드

```c
// 전체 추첨권 수는 totalTickets
int winner = getrandom(0, totalTickets);
int counter = 0;
node_t *current = head;

while (current) {
    counter += current->tickets;
    if (counter > winner)
        break;
    current = current->next;
}
// current가 당첨자
```

#### 🔍 동작 방식
- 전체 추첨권 수를 기준으로 난수를 발생시킴
- 리스트를 순회하며 누적된 추첨권 수(`counter`)가 `winner`보다 커지면 당첨자 결정
- 리스트가 **정렬되어 있을 필요는 없지만**, 효율성을 위해 내림차순 정렬이 좋음

---

### 12.4 실험 예제: 공정성 분석

#### 📊 불공정 지표(Unfairness Metric)
- 두 작업 A, B가 동시에 시작하여 각각 종료할 때,
- **U = A의 종료시간 / B의 종료시간**
- 이상적인 경우 U = 1

→ 시뮬레이션 결과, 작업 시간이 길어질수록 U 값은 1에 가까워짐 → **공정성 증가**

---

### 12.5 추첨권 할당 방식

#### ❓ 문제
- 작업별로 추첨권을 몇 장 줄 것인가?
- 추첨권 수는 공정성/성능에 큰 영향을 줌

#### ✅ 접근 방법
- 사용자 단위로 기준 추첨권을 할당하고, 그 안에서 작업마다 나눔
- 예: User A (기준 1000장) → A1: 500장, A2: 500장  
  → 시스템 전체 기준으로는 A1: 50장, A2: 50장
- 사용자 B는 B1에게 전부 몰아줄 수도 있음

#### 💡 확장 기법
- **추첨권 양도(ticket transfer)**: 클라이언트가 서버에 요청할 때 CPU를 빨리 받도록 서버에게 임시로 추첨권을 넘겨줌
- **팽창(inflation)**: 자신에게 임시로 더 많은 추첨권을 할당 → 협조적 시스템에서 유용

---

### 12.6 보폭 스케줄링 (Stride Scheduling) – 결정적 대안

추첨 스케줄링은 확률적이라 단기 편차가 발생할 수 있음.  
이를 해결하기 위해 나온 결정론적 방식이 **보폭 스케줄링(stride scheduling)** 이다.

#### 📌 핵심 아이디어

- 각 작업은 자신이 가진 추첨권 수에 비례하여 **보폭(stride)** 을 계산
  - 예: stride = 큰 정수 / 추첨권 수
- `pass` 값을 유지하고, **가장 작은 pass 값을 가진 작업을 실행**
- 실행할 때마다 pass += stride

#### 💻 예제

- A: 100장 → stride = 100
- B: 50장 → stride = 200
- C: 250장 → stride = 40

| 순서 | 실행 작업 | Pass 값 변화 (A/B/C) |
|------|-----------|-----------------------|
| 1    | A         | 100 / 0 / 0           |
| 2    | B         | 100 / 200 / 0         |
| 3    | C         | 100 / 200 / 40        |
| 4    | C         | 100 / 200 / 80        |
| 5    | C         | 100 / 200 / 120       |
| 6    | A         | 200 / 200 / 120       |
| 7    | C         | 200 / 200 / 160       |
| 8    | C         | 200 / 200 / 200       |

→ C가 5회, A가 2회, B가 1회 실행됨 → 정확히 250:100:50 비율!

---

### 12.7 추첨 vs 보폭: 언제 어떤 걸 쓸까?

| 항목 | 추첨 스케줄링 | 보폭 스케줄링 |
|------|----------------|----------------|
| 방식 | 확률 기반 | 결정론적 |
| 공정성 | 장기적으로 수렴 | 단기에도 정확 |
| 상태 관리 | 간단 (추첨권만) | 복잡 (pass/stride 관리) |
| 새 작업 도착 | 처리 간편 | 초기 pass 값 설정 어려움 |
| 적용 예시 | 협조적 시스템, 가상화 | 리얼타임 시스템, 정밀 자원 제어 |

---

## ✅ 요약

- **비례 배분 스케줄링**은 각 작업에 일정 비율의 CPU 시간을 보장하기 위한 정책이다.
- **추첨 스케줄링**은 간단하고 무작위 기반으로, 긴 실행 시간 동안 **확률적으로** 비율을 맞춘다.
- **보폭 스케줄링**은 결정론적 방식으로, 매 실행마다 정확한 비율을 맞춘다.
- 공정성, 단기 응답, 자원 분배의 정밀도에 따라 적절한 방식 선택이 필요하다.

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
