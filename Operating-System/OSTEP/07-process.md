# 🧠 Chapter 7. 프로세스의 개념

운영체제가 제공하는 가장 핵심적인 추상화 중 하나인 **프로세스(Process)** 는 실행 중인 프로그램을 의미한다.  
운영체제는 단 하나의 CPU를 가지고도 마치 수십 개의 프로그램이 동시에 실행되는 것처럼 **CPU 가상화**를 구현한다.

---

## 📌 핵심 질문  
> **CPU가 여러 개 존재하는 것처럼 보이게 하려면 어떻게 해야 하는가?**

---

## 7.1 프로세스란?

- **프로세스 = 실행 중인 프로그램**
- 프로그램은 디스크에 저장된 정적인 명령어 묶음일 뿐이고, 프로세스는 운영체제가 그것을 메모리에 로드해 생명을 불어넣은 상태

### 📦 프로세스가 갖는 정보
| 구성 요소 | 설명 |
|------------|------|
| **코드** | 실행할 명령어 (text segment) |
| **데이터** | 전역 변수, 정적 변수 등 |
| **스택** | 함수 호출, 지역 변수, 리턴 주소 등 |
| **힙** | `malloc()`으로 동적 할당된 공간 |
| **레지스터** | PC, SP, FP 등 하드웨어 상태 |
| **파일 디스크립터** | 입출력 상태 (STDIN, STDOUT 등) |

---

## 7.2 프로세스 API

| 기능 | 설명 |
|------|------|
| `Create` | 새 프로세스 생성 (예: `fork()`) |
| `Destroy` | 프로세스 강제 종료 |
| `Wait` | 다른 프로세스가 끝날 때까지 대기 |
| `Control` | 일시 정지, 재시작 등 |
| `Status` | 프로세스 상태 조회 (PID, 실행 시간 등) |

👉 **정책(policy)** 과 **기법(mechanism)** 을 분리해서 설계하는 것이 일반적이다.

---

## 7.3 프로세스 생성: 어떻게 실행되는가?

1. **코드 및 데이터**를 디스크에서 메모리로 로드
2. **스택** 할당 및 `argc`, `argv` 초기화
3. **힙(heap)** 영역 설정
4. 기본 입출력 (STDIN/STDOUT/STDERR) 초기화
5. **`main()`으로 진입**, CPU를 넘김

---

## 7.4 프로세스 상태 (Process State)

| 상태 | 설명 |
|------|------|
| `Running` | 현재 CPU에서 실행 중 |
| `Ready` | 실행 가능한 상태이지만 CPU를 기다림 |
| `Blocked` | 입출력 등 외부 이벤트 대기 중 |

### 예시 시나리오

```
시간    Process0     Process1     비고
1       실행        준비
2       실행        준비
3       실행        준비       Process0 → 입출력 요청
4       대기        실행
5       대기        실행
6       준비        실행       입출력 완료
7       준비        실행       Process1 종료
8       실행        -          Process0 재개 후 종료
```

---

## 7.5 프로세스 자료 구조 (PCB)

운영체제는 각 프로세스를 추적하기 위해 **PCB(Process Control Block)** 를 사용함.

```cpp
struct proc {
    char *mem;
    uint sz;
    char *kstack;
    enum proc_state state;
    int pid;
    struct proc *parent;
    ...
    struct context context;
    struct trapframe *tf;
};
```

- 레지스터 상태: `context`  
- 프로세스 상태: `state` (READY, RUNNING, BLOCKED 등)
- 부모 프로세스 정보, 파일 디스크립터 등도 포함

---

## 7.6 요약

- **프로세스는 실행 중인 프로그램이며, 운영체제는 이를 관리하기 위해 다양한 상태 및 자료구조를 유지한다.**
- CPU를 여러 프로세스에 시분할하여 실행함으로써, 사용자에게는 동시에 실행되는 것처럼 보이게 만든다.
- 실제 구현에서는 **문맥 교환(context switch)**, **스케줄러**, **프로세스 생성 및 종료 처리** 등이 함께 동작한다.

---

## 🧪 숙제 시뮬레이터 (`process-run.py`)

OSTEP는 다양한 시뮬레이터를 통해 개념을 실습할 수 있게 한다.

예시:
```bash
./process-run.py -l 5:100,5:100 -c
./process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IO
```

옵션:
- `-l`: 작업 스케줄 정의
- `-c`: 실행 결과 확인
- `-S`: 스케줄링 방식 (예: SWITCH_ON_IO)
- `-I`: 입출력 완료 후 처리 방식 (IO_RUN_LATER, IO_RUN_IMMEDIATE)

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
