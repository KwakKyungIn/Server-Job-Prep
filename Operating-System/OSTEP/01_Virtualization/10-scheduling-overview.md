# ⏱️ 스케줄링: 개요 (OSTEP Chapter 10)

운영체제는 여러 프로세스들이 CPU를 효율적으로 사용할 수 있도록 **스케줄링 정책(scheduling policy)** 을 사용한다. 이 장에서는 스케줄러가 어떤 기준으로 프로세스를 실행할지 결정하는 다양한 정책과, 이를 평가하기 위한 기준들에 대해 학습한다.

---

## ❓ 핵심 질문

> **스케줄링 정책은 어떻게 개발하고, 어떤 기준으로 평가해야 할까?**

---

## 🔍 상세 개념 정리

### 10.1 워크로드에 대한 가정

정책을 비교하려면 **공정한 실험 조건**, 즉 워크로드(workload)에 대한 가정이 필요하다.

#### 📌 기본 가정

1. 모든 작업은 같은 시간에 도착한다.
2. 작업은 도착 후 실행되며 중단 없이 완료된다.
3. 각 작업은 CPU만 사용하고, 입출력은 없다.
4. 각 작업의 실행 시간은 사전에 알려져 있다.

> 현실과는 다소 동떨어진 가정이지만, 학습을 위해 매우 유용하며 점차 완화해 나간다.

---

### 10.2 스케줄링 평가 항목

#### 🧮 주요 평가 지표

| 항목 | 설명 |
|------|------|
| ⏳ 반환 시간 (Turnaround Time) | 작업 완료 시점 − 도착 시점 |
| 💬 응답 시간 (Response Time) | 작업이 처음 실행될 때 − 도착 시점 |
| ⚖️ 공정성 (Fairness) | 모든 작업이 골고루 CPU를 할당받는 정도 |

> 현실에서는 하나만 좋은 정책은 없다. 응답 시간이 좋으면 반환 시간이 나빠지고, 그 반대도 성립한다.

---

### 10.3 FIFO – 선입선출 스케줄링

**First In, First Out (FIFO)** 또는 **FCFS**는 가장 단순한 스케줄링 정책이다.

- 가장 먼저 도착한 작업을 먼저 실행
- 매우 구현이 간단함

#### 📌 예시 1
A, B, C 작업이 순서대로 도착하고, 각각 10초 실행한다고 가정

| 작업 | 종료 시간 | 반환 시간 |
|------|-----------|-----------|
| A    | 10        | 10        |
| B    | 20        | 20        |
| C    | 30        | 30        |

→ 평균 반환 시간: **20**

#### 📌 예시 2 (Convoy Effect)
A = 100초, B/C = 10초

| 작업 | 종료 시간 | 반환 시간 |
|------|-----------|-----------|
| A    | 100       | 100       |
| B    | 110       | 110       |
| C    | 120       | 120       |

→ 평균 반환 시간: **110**

> 짧은 작업들이 긴 작업 뒤에서 기다리며 비효율 발생 = **호위 효과(Convoy Effect)**

---

### 10.4 SJF – 최단 작업 우선

**Shortest Job First (SJF)** 는 실행 시간이 가장 짧은 작업을 먼저 실행한다.

#### 📌 예시
A = 100초, B/C = 10초

- 실행 순서: B → C → A

| 작업 | 종료 시간 | 반환 시간 |
|------|-----------|-----------|
| B    | 10        | 10        |
| C    | 20        | 20        |
| A    | 120       | 120       |

→ 평균 반환 시간: **50**

> FIFO보다 훨씬 효율적. 평균 반환 시간이 크게 감소한다.

---

### 10.5 STCF – 최소 잔여시간 우선 (선점형)

**Shortest Time to Completion First (STCF)** 또는 선점형 SJF는 새로운 작업이 도착했을 때 **남은 시간이 더 짧다면 기존 작업을 중단**하고 새 작업을 실행한다.

#### 📌 예시
- A(도착 0초, 100초)
- B/C(도착 10초, 각 10초)

→ B와 C가 도착하자마자 A를 **선점**

| 작업 | 종료 시간 | 반환 시간 |
|------|-----------|-----------|
| B    | 20        | 10        |
| C    | 30        | 20        |
| A    | 120       | 120       |

→ 평균 반환 시간: **50**

> 비선점형 SJF보다 더 유연하고 성능도 향상됨

---

### 10.6 응답 시간 도입

**응답 시간 (Response Time)** = 작업이 처음 **시작되는 시점 − 도착 시점**

- SJF나 STCF는 응답 시간이 나쁠 수 있음
- B, C가 뒤늦게 도착했을 때 A가 너무 오래 실행되면 응답 시간이 길어진다

> 대화형 시스템에서는 응답 시간이 **매우 중요한 지표**

---

### 10.7 Round-Robin – 라운드 로빈

**Round-Robin (RR)** 은 각 작업을 **짧은 시간 단위(Time Slice)** 로 번갈아가며 실행

- 예: A, B, C가 동시에 도착하고 각각 5초 필요
- 타임 슬라이스 = 1초

→ 실행 순서: A → B → C → A → B → C ...

| 작업 | 종료 시간 | 반환 시간 |
|------|-----------|-----------|
| A    | 13        | 13        |
| B    | 14        | 14        |
| C    | 15        | 15        |

→ 평균 반환 시간: **14**

→ 응답 시간: A=0, B=1, C=2 → 평균 응답 시간 **1**

> 응답 시간은 짧지만 반환 시간은 상대적으로 나쁠 수 있음

---

### 10.8 입출력 연산 고려

이제 **입출력**이 포함된 워크로드를 고려한다.

- A: 10ms 실행 → 10ms 입출력 → 반복
- B: CPU 집중형, 50ms 실행

**스케줄링 전략**:
- A의 CPU 버스트를 **짧은 작업처럼 취급**
- B보다 A를 우선 실행 (STCF 기반)
- 입출력 중인 A는 **대기 상태**, 그 사이에 B 실행

> CPU와 I/O의 **중첩 실행**으로 시스템 자원을 더 효율적으로 사용

---

### 10.9 만병통치약은 없다

SJF/STCF는 **작업 실행 시간을 미리 알아야** 한다는 가정을 전제로 한다.

- 하지만 현실에서는 실행 시간을 알 수 없음
- 미래를 예측할 수 없다면 최적 스케줄링은 불가능
- 과거의 실행 패턴을 기반으로 예측하는 방식으로 대체해야 함

---

## ✅ 요약

- **FIFO**: 단순하지만 긴 작업이 짧은 작업을 가로막을 수 있음
- **SJF/STCF**: 평균 반환 시간 최적화, 선점 가능, 응답 시간은 나쁨
- **Round-Robin**: 응답 시간 최적화, 타임 슬라이스 중요, 반환 시간은 나쁨
- **입출력 고려**: CPU와 I/O를 중첩시켜 자원 활용 극대화
- **실행 시간 예측 불가**: 미래 예측이 불가능하므로 현실에선 예측 기반 스케줄러가 필요

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
