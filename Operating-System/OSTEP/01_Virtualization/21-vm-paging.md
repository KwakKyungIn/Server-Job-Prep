# 📑 가상 메모리: 페이징의 개요 (OSTEP Chapter 21)

이 장에서는 가상 메모리 구현 방식 중 하나인 **페이징(paging)** 의 개념을 소개한다.  
고정 크기의 페이지 단위로 주소 공간과 물리 메모리를 관리함으로써 **세그멘테이션의 단편화 문제를 해결**하고, 주소 공간 사용을 더 유연하게 만든다.

---

## ❓ 핵심 질문

> 가상 메모리에서 공간 낭비 없이 메모리를 가상화하려면 어떻게 해야 할까?  
> → 고정 크기의 페이지로 나누어 관리하면 어떤 장점과 단점이 생길까?

---

## 🔍 상세 개념 정리

### 21.1 페이징의 기본 개념

#### 🧱 기본 아이디어
- 주소 공간과 물리 메모리를 **동일한 크기의 고정 크기 블록**으로 나누어 관리
- 가상 메모리: 페이지(Page)
- 물리 메모리: 페이지 프레임(Page Frame)

#### 🎯 장점
- 세그멘테이션처럼 **외부 단편화(External Fragmentation)** 발생 X
- 프로세스의 주소 공간이 **드문드문(sparse) 배치**되어도 효율적
- 힙/스택의 성장 방향 등 사용 패턴과 무관하게 관리 가능

---

### 21.2 간단한 예시

#### 🖥️ 가상 주소 공간
- 크기: 64바이트
- 페이지 크기: 16바이트 → 총 4개 페이지 (VPN 0 ~ 3)

#### 💾 물리 메모리
- 크기: 128바이트
- 페이지 프레임 크기: 16바이트 → 총 8개 프레임

#### 🛡️ 배치 예시
| 가상 페이지 | 물리 프레임 |
|-------------|-------------|
| VP 0        | PF 3        |
| VP 1        | PF 7        |
| VP 2        | PF 5        |
| VP 3        | PF 2        |

#### 🔍 주소 변환 과정
가상 주소 21 (2진수 010101):
- VPN = 상위 2비트 → `01` → VPN 1
- 오프셋 = 하위 4비트 → `0101` → 5

페이지 테이블에서 VPN 1 → PF 7 확인
→ 물리 주소 = PFN 7(111) + 오프셋 0101 → `1110101` = 117

---

### 21.3 페이지 테이블의 역할

#### 🛠️ 구조
- 가상 페이지 번호(VPN)를 물리 프레임 번호(PFN)로 변환하는 테이블
- 프로세스마다 별도 존재 (**프로세스 독립적 주소 공간 제공**)

#### 📦 저장 위치
- CPU MMU에 내장 불가 (너무 큼)
- 운영체제의 물리 메모리 또는 가상 메모리에 저장

---

### 21.4 페이지 테이블 항목 (Page Table Entry, PTE)

#### ✅ 필드 구성
| 비트 | 역할 |
|-----|------|
| Valid | 이 페이지가 유효한지 여부 |
| PFN | 매핑된 물리 프레임 번호 |
| R/W | 읽기/쓰기 권한 |
| U/S | 사용자/커널 접근 여부 |
| Dirty | 수정 여부 |
| Referenced | 최근 사용 여부 |
| Present | 메모리에 존재 여부 |

> 예: Linux, x86 아키텍처 기준

---

### 21.5 페이징의 성능 문제

#### ⚠️ 느려지는 원인
- 가상 주소 → 물리 주소 변환 시 매번 페이지 테이블 조회 필요
- 하나의 메모리 접근을 위해 **최소 2번 메모리 접근**:
  1. 페이지 테이블 조회
  2. 실제 데이터 접근

#### 🔧 기본 변환 과정
```text
1. VPN 추출: (VirtualAddress & VPN_MASK) >> SHIFT
2. PTE 조회: PageTableBaseRegister + (VPN * PTE 크기)
3. 유효성/권한 검사
4. PFN 추출 후 물리 주소 계산: (PFN << SHIFT) | offset
```

→ 이렇게 하면 기본 명령어도 두 번의 메모리 접근이 필요함 → **성능 저하**

---

### 21.6 페이징을 사용할 때 발생하는 메모리 액세스 예시

#### 예제 코드
```c
int array[1000];
for (int i = 0; i < 1000; i++)
    array[i] = 0;
```

#### 메모리 액세스 패턴
- 코드 실행 시: 명령어 fetch → 페이지 테이블 조회 + 명령어 read
- 배열 초기화 시: 데이터 write → 페이지 테이블 조회 + 데이터 write

#### 결과
- 루프 내 명령어 하나당 **2~3번의 메모리 접근** 필요

---

### 21.7 페이징의 핵심 문제점

| 문제 | 설명 |
|------|------|
| 성능 문제 | 매번 주소 변환 → 메모리 접근 2배 이상 |
| 테이블 크기 문제 | 가상 주소 공간이 클수록 페이지 테이블도 커짐 |
| 시간/공간 오버헤드 | 가상화의 핵심 trade-off |

---

## ✅ 요약

페이징은 고정 크기 블록 단위로 주소 공간을 관리하여:
- 외부 단편화 문제를 해결하고,
- 드문드문한 주소 공간 사용을 허용하며,
- 프로그램의 물리 주소 의존성을 제거한다.

하지만 페이지 테이블의 크기와 성능 오버헤드라는 새로운 문제가 발생한다.
이를 해결하기 위한 개선 방식이 다음 장에서 다루어진다.

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
