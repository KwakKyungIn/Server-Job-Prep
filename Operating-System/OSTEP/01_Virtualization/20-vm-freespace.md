# 🧹 가상 메모리: 빈 공간 관리 (OSTEP Chapter 20)

메모리 관리 시스템의 중요한 역할 중 하나는 **사용 가능한 빈 공간(free space)을 관리하는 것**이다.  
이 장에서는 `malloc()` 같은 사용자 수준 메모리 관리부터 운영체제의 세그멘테이션까지, **가변 크기 메모리 할당 시 발생하는 외부 단편화 문제**를 최소화하는 다양한 전략을 배운다.

---

## ❓ 핵심 질문

> 크기가 서로 다른 요청들이 반복적으로 발생할 때, **빈 공간을 어떻게 관리해야 단편화를 줄이고 효율적으로 할당할 수 있을까?**

---

## 🔍 상세 개념 정리

### 20.1 문제 정의와 기본 가정

#### ⚙️ 관리 대상
- 사용자 수준: `malloc()`, `free()`
- 커널 수준: 세그멘테이션 기반 물리 메모리 관리

#### 📌 외부 단편화(External Fragmentation)란?
- 전체 빈 공간의 총합은 충분한데, **연속된 충분한 공간이 없어서 요청을 처리하지 못하는 상황**
  
#### 📉 예시
- 빈 공간 10바이트 + 10바이트 = 총 20바이트
- 요청: 15바이트 → 실패 (연속 공간이 없음)

---

### 20.2 저수준 관리 기법

#### 🔧 분할(Splitting)과 병합(Coalescing)

##### ▶ 분할
- 큰 빈 공간 → 필요한 만큼 할당, 나머지는 빈 공간으로 남김

##### ▶ 병합
- 인접한 빈 공간이 생기면 하나로 합침
- → 더 큰 연속 공간 확보 가능

##### 예시 흐름
1. 20바이트 빈 공간
2. 1바이트 요청 → 1바이트 할당, 19바이트 빈 공간 남김
3. 사용자가 반환하면, 인접한 빈 공간과 병합하여 다시 20바이트 확보 가능

---

#### 🏷️ 할당된 영역 크기 추적 (헤더 사용)

```c
typedef struct __header_t {
    int size;
    int magic;
} header_t;
```

- `free()`는 포인터만 받고 크기를 받지 않음
- → 메모리 블록 앞에 **헤더(Header)** 를 둬서 크기, 무결성 검사(magic number) 등을 저장
- 해제 시 헤더를 역참조하여 크기 확인 후 빈 공간 리스트에 추가

---

#### 📋 빈 공간 리스트 내장 방식

##### 기본 구조
```c
typedef struct __node_t {
    int size;
    struct __node_t *next;
} node_t;
```

##### 예시 초기화
```c
node_t *head = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
head->size = 4096 - sizeof(node_t);
head->next = NULL;
```

- 빈 공간 자체에 리스트 정보를 저장 → 별도 메모리 할당 불필요

---

### 20.3 기본 할당 전략들

#### 🎯 최적 적합 (Best Fit)
- 가장 **작게 남는** 빈 블록 선택 → 공간 낭비 최소화
- 단점: 항상 전체 리스트를 검색해야 해서 성능 저하

#### 🎯 최악 적합 (Worst Fit)
- 가장 **큰** 빈 블록에서 할당 → 큰 블록 유지 시도
- 단점: 오히려 큰 단편화 발생 가능

#### 🎯 최초 적합 (First Fit)
- 처음 발견한 충분한 블록을 사용
- 장점: 빠름 (부분 탐색)
- 단점: 작은 블록이 앞쪽에 쌓여 단편화 발생 가능

#### 🎯 다음 적합 (Next Fit)
- 마지막 사용한 블록 이후부터 검색
- 장점: 검색 균등 분산
- 단점: 최적성과는 무관

---

### 20.4 고급 기법들

#### ⚙️ 개별 리스트 (Segregated List)
- 요청 크기별로 별도의 리스트 유지
- 자주 요청되는 크기에 효율적
- 예: 커널 락, 아이노드 등 → 고정 크기별 리스트 구성

#### ⚙️ 슬랩 할당기 (Slab Allocator)
- Solaris의 커널 구조체 캐싱 기법
- 미리 초기화된 메모리 청크들을 유지
- 장점: 재할당 시 초기화 비용 감소, 빠른 응답

#### ⚙️ 버디 할당기 (Buddy Allocator)
- 메모리를 2의 거듭제곱 크기로 나눔
- 요청 크기보다 큰 공간을 계속 1/2씩 나누어 사용
- 해제 시 주소 기반으로 버디를 찾아서 재병합
- 장점: 빠른 병합, 단점: 내부 단편화 발생

---

### 20.5 확장성 문제와 기타 구조

- 빈 공간이 많아질수록 리스트 탐색 비용 ↑
- → **균형 트리(Balanced Tree)**, **스플레이 트리(Splay Tree)** 같은 고급 자료구조 사용
- 멀티스레드 환경에서는 락 충돌을 줄이기 위한 최적화 필요
  - jemalloc (FreeBSD, Firefox, Facebook 등 사용)
  - Hoard, tcmalloc 등

---

## ✅ 요약

빈 공간 관리 문제는 단순해 보이지만 성능과 효율성을 좌우하는 중요한 문제다.  
세그멘테이션, malloc, 커널 메모리 관리 등 다양한 곳에서 필요하다.

| 전략 | 장점 | 단점 |
|------|------|------|
| Best Fit | 공간 낭비 최소화 | 탐색 비용 높음 |
| Worst Fit | 큰 블록 유지 시도 | 성능 및 단편화 모두 나쁨 |
| First Fit | 빠른 탐색 | 앞쪽에 작은 단편화 발생 |
| Next Fit | 탐색 균등 분산 | 최적화는 부족 |

현대 시스템에서는 슬랩, 버디, 균형 트리 등 다양한 최적화 기법이 병행 사용된다.

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
