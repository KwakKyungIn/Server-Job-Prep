# ⚙️ 제한적 직접 실행 (OSTEP Chapter 9)

운영체제가 CPU를 가상화하기 위해 사용하는 핵심 기술 중 하나는 **제한적 직접 실행(Limited Direct Execution, LDE)** 이다. 이 기법은 **프로그램을 가능한 빠르게 직접 CPU에서 실행**시키면서도, **운영체제가 시스템 제어권을 유지할 수 있게** 하는 하드웨어 및 소프트웨어 기술을 포함한다.

---

## ❓ 핵심 질문

> CPU를 직접 실행하면서도, 운영체제가 시스템의 **제어권을 유지**할 수 있는 방법은 무엇인가?

---

## 🔍 상세 개념 정리

### 9.1 제한적 직접 실행의 기본 원리

운영체제는 프로그램을 실행할 때 다음 과정을 수행한다:

1. **프로세스 생성**: PCB(Process Control Block) 생성
2. **메모리 할당 및 코드 적재**: 실행할 프로그램을 메모리에 로딩
3. **레지스터 초기화 및 스택 준비**
4. **`main()`으로 분기**하여 사용자 코드를 실행

이러한 과정을 통해 **CPU에서 사용자 프로그램을 직접 실행**시킨다. 하지만 문제는 운영체제가 이 프로세스의 동작을 **제어하지 못하면** 시스템을 **장악당하거나 영원히 CPU를 점유당할 수 있다는 점**이다.

> 그래서 **제한적** 직접 실행이 필요하다.

---

### 9.2 문제점 1: 제한된 연산 – 사용자 모드와 시스템 콜

사용자가 **출력, 파일 I/O, 프로세스 생성, 메모리 할당** 등을 하고자 할 때는 단순히 직접 CPU 명령을 실행해선 안 된다. 이는 보안과 안정성 문제를 일으킬 수 있기 때문이다.

#### 🛡️ 해결책: 실행 모드 분리

| 모드 | 설명 |
|------|------|
| **사용자 모드 (User Mode)** | 제한된 권한. 시스템 자원 접근 불가 |
| **커널 모드 (Kernel Mode)** | 운영체제 코드. 모든 자원 접근 가능 |

운영체제는 **trap (시스템 콜 진입)** 명령어를 통해 **사용자 → 커널** 전환을 제공하고, **return-from-trap** 명령어를 통해 다시 사용자 모드로 복귀한다.

#### 📌 시스템 콜 흐름 (예: `open()`)

1. 사용자 코드에서 `open()` 호출
2. C 라이브러리 → 어셈블리로 구현된 trap 명령 실행
3. 하드웨어가 커널 모드로 전환 + trap handler 호출
4. 운영체제가 요청 처리
5. return-from-trap으로 사용자로 복귀

> 시스템 콜은 일반 함수 호출처럼 보이지만, **실제로는 trap 명령을 내포한 특수한 인터페이스**다.

#### 🖼️ 요약 그림: 제한적 직접 실행 프로토콜

- trap table 초기화
- syscall 발생 시 trap으로 진입
- 커널 모드에서 처리
- 사용자 모드로 복귀 후 프로그램 재개

---

### 9.3 문제점 2: 프로세스 간 전환 – CPU 강탈

한 프로세스가 CPU를 **영원히 점유**하면? 운영체제는 다음 프로세스를 실행할 수 없게 된다. 이를 막기 위해 운영체제가 **CPU 제어권을 다시 획득해야 한다.**

#### 방법 1️⃣ 협조적(cooperative) 방식

- 프로세스가 자발적으로 `yield()`나 `read()` 같은 시스템 콜을 호출하여 CPU를 포기
- 초기 macOS, Xerox Alto에서 사용
- **문제점**: 루프에 빠진 프로세스가 시스템 콜을 호출하지 않으면, 운영체제는 무력하다

#### 방법 2️⃣ 비협조적(preemptive) 방식: **타이머 인터럽트**

- 하드웨어 타이머가 일정 주기로 인터럽트를 발생시킴
- 운영체제의 **인터럽트 핸들러**가 실행되어 CPU 제어권을 다시 획득
- 그 후 **스케줄러**가 다른 프로세스를 선택하여 실행

> 비협조적 방식은 현대 시스템의 기본이며, 운영체제가 항상 제어권을 가질 수 있도록 한다

#### 📌 타이머 인터럽트 흐름

1. 타이머 설정 (OS 부팅 시)
2. x ms 후 인터럽트 발생
3. 현재 프로세스 상태 저장 (레지스터, PC 등)
4. 커널 모드 진입
5. 스케줄러가 실행할 다음 프로세스 선택
6. 문맥 교환(Context Switch) 수행
7. 새로운 프로세스로 복귀

---

### 9.4 문맥 교환 (Context Switch)

운영체제가 프로세스 A에서 프로세스 B로 **CPU 제어를 넘기기 위한 핵심 기술**

#### ✅ 수행 작업

- 현재 프로세스 A의 레지스터 값, 커널 스택, PC 등 저장
- 다음 실행할 프로세스 B의 상태 복원
- 스택 포인터 전환
- `return-from-trap` → B의 코드 실행 시작

#### 💻 xv6의 실제 문맥 교환 코드 (Assembly)

```asm
# switch(struct context **old, struct context *new)
.globl switch
switch:
  # Save current registers
  movl 4(%esp), %eax
  popl 0(%eax)
  movl %esp, 4(%eax)
  movl %ebx, 8(%eax)
  movl %ecx, 12(%eax)
  ...

  # Load new registers
  movl 4(%esp), %eax
  movl 28(%eax), %ebp
  movl 24(%eax), %edi
  ...
  ret
```

#### 📈 문맥 교환 비용

| 항목 | 시간 (1996년 기준) |
|------|--------------------|
| 시스템 콜 | 4μs |
| 문맥 교환 | 6μs |

> 오늘날에는 1μs 미만까지 줄어들었지만, 여전히 중요한 성능 요소다.

---

### 9.5 병행성 문제 (잠깐 맛보기)

- 트랩 처리 중 또 다른 인터럽트가 발생하면? → **Nested Interrupt**
- 커널 데이터 접근 중 경쟁 발생 가능
- 해결책:
  - 인터럽트 비활성화 (일시적)
  - 락(lock) 사용
- 더 자세한 내용은 **병행성 챕터**에서 다룬다

---

## ✅ 요약

| 구성 요소 | 설명 |
|-----------|------|
| 제한적 직접 실행 | 프로그램을 직접 CPU에서 실행하지만, 제어권은 OS가 유지 |
| 사용자/커널 모드 | 권한 분리: 사용자 제한, 커널은 전권 |
| 시스템 콜 | 사용자 → 커널로 진입하는 안전한 통로 |
| 타이머 인터럽트 | 비협조적 프로세스도 제어 가능하게 함 |
| 문맥 교환 | 실행 중인 프로세스 상태 저장 + 새 프로세스 복원 |
| trap table | 시스템 콜/인터럽트 발생 시 실행할 코드 위치 등록 |

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』

> 💡 다음 챕터는 **스케줄러가 어떤 기준으로 프로세스를 선택하는지**에 대한 내용이야. (정책)
