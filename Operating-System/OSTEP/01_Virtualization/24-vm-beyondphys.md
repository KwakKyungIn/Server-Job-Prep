# 🗄️ 가상 메모리: 물리 메모리를 넘어서는 확장 (OSTEP Chapter 24)

지금까지는 가상 메모리의 모든 페이지가 물리 메모리에 존재한다고 가정했지만, 현실에서는 **물리 메모리가 부족**하다.  
운영체제는 디스크 같은 **느리고 큰 저장 장치**를 사용하여 더 큰 가상 메모리를 제공하는데, 이 과정에서 스왑 공간, 페이지 폴트 등 다양한 메커니즘이 필요하다.

---

## ❓ 핵심 질문

> 실제 메모리보다 더 큰 가상 주소 공간을 제공하기 위해, 운영체제는 어떻게 물리 메모리 외부의 느린 저장 장치를 활용할까?

---

## 🔍 상세 개념 정리

### 24.1 스왑 공간 (Swap Space)

#### 🛡️ 개념
- **물리 메모리에 없는 페이지들을 임시로 저장하는 디스크 공간**
- 페이지 교체 시 메모리 ↔ 디스크로 페이지 이동
- → 메모리가 부족해도 프로그램은 연속된 주소 공간을 사용하는 것처럼 보임

#### 🛠️ 용도
- 프로세스의 코드/데이터 페이지 저장
- 미사용 중인 페이지 스왑 아웃 (swap out)
- 필요할 때 다시 스왑 인 (swap in)

#### 📊 예시
| 공간 | 수용 페이지 |
|------|-------------|
| 물리 메모리 | 4개 |
| 스왑 공간 | 8개 |
| 총 페이지 수 | 최대 12개 |

---

### 24.2 Present 비트

#### ✅ 역할
- 페이지 테이블 항목(PTE)에 있는 비트
- **1**: 물리 메모리에 있음
- **0**: 스왑 공간에 있음 → 접근 시 **페이지 폴트(page fault)** 발생

#### 📈 동작 흐름
1. 주소 변환 시 TLB 미스 발생 → 페이지 테이블 조회
2. PTE의 Present 비트 확인
3. `0`이면 → **페이지 폴트 예외 발생**
4. 운영체제가 디스크에서 페이지를 읽어옴

---

### 24.3 페이지 폴트(Page Fault)

#### ⚠️ 정의
- 프로세스가 **존재하지 않는 페이지에 접근**할 때 발생
- 합법적인 접근이지만, 페이지가 현재 메모리에 없음

#### 🔧 처리 과정
1. 운영체제가 스왑 공간에서 페이지 위치 확인
2. 빈 물리 프레임 찾기 (없으면 교체 필요)
3. 디스크에서 페이지 읽어오기
4. 페이지 테이블 갱신 + TLB 갱신
5. 명령어 재실행

#### 📂 예시
```text
if (PTE.Present == 0) → PAGE_FAULT 발생
```

---

### 24.4 물리 메모리가 부족하면?

#### 📉 문제
- 메모리에 여유 공간이 없으면, 기존 페이지를 내보내야 함

#### 🔄 페이지 교체 정책(Page Replacement Policy)
- 어떤 페이지를 내보낼지 결정하는 알고리즘
- 잘못된 선택 시 성능 심각하게 저하 가능
  - 페이지를 자주 교체하면 → 성능이 디스크 수준으로 떨어짐

→ 구체적 정책은 다음 장에서 설명

---

### 24.5 페이지 폴트의 세부 처리 과정

#### 📜 하드웨어 동작 요약
| 상황 | 처리 |
|------|------|
| TLB Hit | 물리 주소로 변환 → 바로 접근 |
| TLB Miss + Present=1 | PTE에서 변환 후 TLB에 등록 |
| TLB Miss + Present=0 | 페이지 폴트 발생, OS에게 제어권 이양 |

#### 🛡️ 소프트웨어 처리 과정
```text
1. 빈 프레임 찾기 (없으면 교체)
2. 디스크에서 페이지 읽기
3. 페이지 테이블/Present 비트 갱신
4. TLB 미스 발생 후 재실행 → 최종적으로 메모리 접근 성공
```

---

### 24.6 교체 시점: 언제 페이지를 내보낼까?

#### 기본 원칙
- 여유 메모리가 충분히 있을 때는 교체 안 함
- 운영체제는 항상 일정량의 여유 공간 확보

#### ✅ High/Low 워터마크 방식
| 워터마크 | 동작 |
|----------|------|
| High     | 여유 공간 충분 → 교체 필요 없음 |
| Low      | 여유 공간 부족 → **백그라운드 데몬이 페이지 교체 시작**

#### 🔄 클러스터 교체
- 여러 페이지를 묶어서 교체 → 디스크 접근 효율 ↑

#### 🧑‍💻 백그라운드 작업: Swap Daemon
- 시스템이 바쁠 때 대신, 유휴 시간에 교체 작업 수행
- 디스크 입출력을 효율적으로 스케줄링

---

### 💡 과거에는 어땠나?
과거 시스템에서는 가상 메모리 대신 **메모리 오버레이(memory overlay)** 사용:
- 프로그래머가 수동으로 코드/데이터를 메모리에 적재/제거
- 현재는 운영체제가 자동으로 관리

---

## ✅ 요약

운영체제는 물리 메모리를 넘어서는 **가상 주소 공간**을 제공하기 위해, 스왑 공간과 페이지 폴트 처리 메커니즘을 사용한다.  
페이지가 메모리에 없을 때는 디스크에서 읽어오며, 이 과정은 사용자가 전혀 인식하지 못한 채 진행된다.

| 기능 | 역할 |
|------|------|
| 스왑 공간 | 물리 메모리 부족 시 임시 저장 |
| Present 비트 | 물리 메모리에 있는지 여부 표시 |
| 페이지 폴트 | 없는 페이지 접근 시 발생, OS가 처리 |
| 교체 정책 | 어떤 페이지를 내보낼지 결정 |
| Swap Daemon | 유휴 시간에 페이지 교체 작업 수행 |

결과적으로, 운영체제는 **작은 물리 메모리로도 큰 가상 주소 공간을 관리**할 수 있게 된다.

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
