# 📐 가상 메모리: 세그멘테이션 (OSTEP Chapter 19)

Base/Bound 방식은 간단하지만, 프로세스 주소 공간 전체가 하나의 연속적인 물리 메모리 공간에 매핑된다는 문제점이 있다. 특히, **스택과 힙 사이의 미사용 공간까지 모두 메모리에 할당**되는 비효율이 발생한다. 이를 해결하기 위해 등장한 것이 **세그멘테이션(segmentation)** 이다.

---

## ❓ 핵심 질문

> **주소 공간이 드문드문(sparse) 사용될 때, 전체 공간을 물리 메모리에 모두 적재하지 않고 효율적으로 관리하려면 어떻게 해야 할까?**

---

## 🔍 상세 개념 정리

### 19.1 세그멘테이션: Base/Bound의 확장

#### ✅ 개념
- 하나의 주소 공간을 여러 개의 **세그먼트(segment)** 로 나누고,
- 각 세그먼트마다 별도의 **Base/Bound 레지스터 쌍**을 사용
- → 사용 중인 부분만 물리 메모리에 배치 가능

#### 📦 예시 세그먼트
| 세그먼트 | 내용           |
|----------|----------------|
| 코드     | 프로그램 명령어 |
| 힙       | 동적 할당 메모리 |
| 스택     | 함수 호출용 스택 |

#### 🔧 하드웨어 구성 (예)
| 세그먼트 | Base | 크기 | 방향 |
|----------|------|------|------|
| 코드     | 32KB | 2KB  | 증가 |
| 힙       | 34KB | 2KB  | 증가 |
| 스택     | 28KB | 2KB  | 감소 |

#### 🛡️ 효과
- 미사용 공간은 메모리 할당하지 않음 → **메모리 절약**
- 세그먼트마다 다른 물리 주소 공간 사용 가능 → 유연성 향상

---

### 19.2 주소 변환 과정

#### 예제: 코드 세그먼트
가상 주소 `100` → 코드 세그먼트
```
물리 주소 = 코드 Base (32KB) + 100 → 32KB + 100 = 32868
```

#### 예제: 힙 세그먼트
가상 주소 `4200`, 힙은 4096부터 시작하므로 오프셋 = 4200 - 4096 = 104
```
물리 주소 = 힙 Base (34KB) + 104 → 34KB + 104 = 34920
```

#### 🛡️ 보호
- 오프셋이 Bound를 초과하면 **세그먼트 폴트(segment fault)** 발생

---

### 19.3 세그먼트 구분 방법

#### 📊 방식 1: 가상 주소 상위 비트로 구분 (VAX/VMS 예시)
| 비트 범위 | 의미 |
|-----------|------|
| 상위 2비트 | 세그먼트 종류 |
| 하위 12비트 | 세그먼트 내 오프셋 |

→ 최상위 비트가 00이면 코드, 01이면 힙, 11이면 스택

#### 📊 방식 2: 암묵적 구분
- 코드 실행 주소는 코드 세그먼트
- 스택 포인터 기반 주소는 스택 세그먼트
- 그 외는 힙으로 처리

---

### 19.4 스택: 확장 방향이 다르다

#### ⚙️ 차이점
- 스택은 **높은 주소에서 낮은 주소로 확장**
- 다른 세그먼트는 낮은 주소 → 높은 주소로 확장

#### 변환 예시
가상 주소 15KB, 스택 Base가 28KB, 크기 4KB
→ 오프셋 = 4KB - (16KB - 12KB) = -1KB
```
물리 주소 = Base + 오프셋 = 28KB - 1KB = 27KB
```

→ 하드웨어는 세그먼트마다 **확장 방향 비트**로 이를 관리함

---

### 19.5 세그먼트 공유와 보호

#### ✅ 코드 공유
- 여러 프로세스가 **코드 세그먼트 공유** 가능 (읽기/실행 전용)
- 힙과 스택은 각자 사용

#### 🔐 보호 권한
| 세그먼트 | 보호 설정    |
|----------|---------------|
| 코드     | 읽기/실행만 허용 |
| 힙       | 읽기/쓰기 허용 |
| 스택     | 읽기/쓰기 허용 |

→ 잘못된 접근 시 **Protection Fault**

---

### 19.6 외부 단편화 문제

#### ⚠️ 문제점
- 세그먼트는 크기가 가변적이므로, 물리 메모리가 **작은 빈 공간들로 나뉘는 외부 단편화(external fragmentation)** 발생
- 새로 생성할 세그먼트를 넣을 연속된 공간이 없을 수도 있음

#### 🛠️ 해결책
1. **메모리 압축(compaction)**: 세그먼트를 이동시켜 빈 공간을 모으는 방법 (비용 큼)
2. **빈 공간 관리 알고리즘**:
   - 최초 적합(First Fit)
   - 최적 적합(Best Fit)
   - 버디 시스템 등
   - → 외부 단편화를 줄이지만 완전히 없애진 못함

---

### 19.7 세그멘테이션의 한계

- 내부 단편화는 줄었지만, 외부 단편화는 여전히 존재
- 매우 큰 세그먼트 (예: 힙)라도 전부 물리 메모리에 있어야 함 → 드문드문 사용하는 공간에는 비효율
- 힙을 일부만 적재하거나 세밀하게 나누려면 세그멘테이션만으로는 불충분
- → 다음 장에서 **페이징(Paging)** 으로 개선

---

## ✅ 요약

| 항목 | Base/Bound | 세그멘테이션 |
|------|-------------|----------------|
| 주소 공간 | 하나 | 여러 세그먼트 |
| 단편화 | 내부 단편화 ↑ | 외부 단편화 ↑ |
| 유연성 | 낮음 | 높음 |
| 보호 | 있음 | 세그먼트별 보호 |
| 공유 | 불가 | 코드 공유 가능 |
| 동작 방식 | 가상 주소 + Base | 세그먼트 오프셋 + Base |

세그멘테이션은 메모리 가상화의 두 번째 단계로, **유연한 주소 공간 배치와 메모리 절약**을 가능하게 한다. 하지만 외부 단편화 문제와 대용량 주소 공간 지원의 한계로 인해, 추가적인 개선이 필요하다.

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
