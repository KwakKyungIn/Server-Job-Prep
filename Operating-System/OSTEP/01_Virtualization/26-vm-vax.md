# 🏛️ VAX/VMS 가상 메모리 시스템 (OSTEP Chapter 26)

VAX/VMS 운영체제는 1970~80년대 Digital Equipment Corporation(DEC)에서 개발한 VAX-11 시리즈 컴퓨터의 대표적인 가상 메모리 시스템이다.  
이 장에서는 지금까지 배운 **페이징, 세그멘테이션, 교체 정책 등 가상 메모리 기술이 실제 시스템에서 어떻게 동작했는지** 구체적으로 살펴본다.

---

## ❓ 핵심 질문

> **범용 하드웨어**에서 동작하는 운영체제가, 서로 다른 시스템 환경에서도 일관되고 효율적으로 가상 메모리를 관리하려면 어떻게 해야 할까?

---

## 🔍 상세 개념 정리

### 26.1 VAX/VMS의 역사적 배경

#### 🛡️ 시스템 개요
- VAX-11 시리즈: 32비트 미니컴퓨터, 512B 페이지 사용
- 운영체제: **VMS (Virtual Memory System)**
- 개발자: **Dave Cutler** (후에 Windows NT 개발 총괄)

#### 📉 문제 상황
- 서로 다른 성능/구조의 VAX 시스템들에서 **동일한 운영체제가 동작해야 함**
- 하드웨어만으로는 부족한 부분을 운영체제가 보완해야 했음 (**일반론의 저주**)

---

### 26.2 메모리 관리 하드웨어 구조

#### ✅ 주소 공간 구성
| 영역 | 범위 | 내용 |
|------|------|------|
| P0 | 하위 절반 | 사용자 코드, 힙 (↑ 증가) |
| P1 | 하위 절반 | 스택 (↓ 감소) |
| S  | 상위 절반 | 커널 코드 및 데이터 (모든 프로세스 공유) |

- P0, P1은 프로세스마다 별도 → 독립 주소 공간 제공
- S 영역은 모든 프로세스에 공통 → 운영체제 코드/데이터 공유

#### 🔧 세그멘테이션 + 페이징
- VPN 상위 비트로 세그먼트 구분
- 각 세그먼트별로 별도의 **Base/Bound + 페이지 테이블** 사용

#### 📏 문제점
- 페이지 크기가 작아(512B) 페이지 테이블이 매우 커짐
- 해결책:
  - 세그먼트별 별도 테이블 → 사용하지 않는 주소 공간의 페이지 테이블은 불필요
  - 커널 가상 메모리에 사용자 페이지 테이블(P0/PT, P1/PT)을 저장 → 물리 메모리 절약

---

### 26.3 실제 주소 공간 설계

#### 💡 널 포인터 보호
- 주소 0번지는 **접근 불가능**으로 설정
- 잘못된 널 포인터 접근 시 명확히 오류 검출

#### 🔐 커널 공유
- 커널 공간(S)은 모든 프로세스에 동일하게 매핑
- 커널 코드에서 사용자 포인터를 **그대로 사용할 수 있음**

#### 🔄 문맥 교환
- P0, P1의 Base/Bound만 교체
- 커널(S)은 그대로 유지 → 커널 데이터 유지, 빠른 전환

#### 🛡️ 보호 수준
- 각 페이지마다 보호 비트 설정
- 사용자 → 커널 데이터 접근 시 예외 발생

---

### 26.4 페이지 교체 정책

#### 🔍 페이지 테이블 항목 (PTE)
| 필드 | 역할 |
|------|------|
| Valid | 페이지 유효 여부 |
| Protection | 접근 권한 (4비트) |
| Dirty | 수정 여부 |
| PFN | 물리 프레임 번호 |

#### ❓ Reference Bit 없음
- 하드웨어에서 페이지 참조 여부 판단 불가 → 소프트웨어로 추적 필요

#### ⚙️ 교체 정책: Segmented FIFO
| 항목 | 설명 |
|------|------|
| RSS 제한 | 프로세스별 유지 가능한 최대 페이지 수 |
| FIFO 관리 | 오래된 페이지부터 교체 |
| 전역 second-chance list | 클린/더티 페이지 분리 저장, 재사용 가능성 보존

##### ✅ 동작 과정
- 프로세스 RSS 초과 시 FIFO에서 제거
- 제거된 페이지 → 전역 클린/더티 리스트에 보관
- 다른 프로세스가 필요 시 클린 리스트 우선 사용 → 디스크 접근 최소화
- 원래 프로세스가 재사용 시 다시 가져옴 (Second-Chance)

---

### 26.5 추가 최적화 기법

#### 🧱 페이지 클러스터링
- 디스크 I/O 성능 향상을 위해 **여러 페이지를 묶어서 한 번에 스왑**
- 페이지 크기가 작아도 스왑 효율 유지

#### 🛡️ Demand Zeroing
- 새 페이지 요청 시 바로 0으로 초기화 X
- 접근 시점에만 0으로 초기화 → 불필요한 작업 방지

#### ✨ Copy-on-Write (COW)
- 페이지를 복사하지 않고 공유 상태로 매핑
- 쓰기 발생 시점에만 복사
- → fork() + exec() 최적화 핵심

---

### 26.6 Reference Bit 에뮬레이션

#### 🚨 하드웨어 Reference Bit이 없을 때
- 모든 페이지를 **읽기 불가로 설정**
- 접근 시 예외 발생 → 운영체제가 접근 여부 기록 후 권한 복원
- 주기적으로 다시 읽기 불가 설정해 최신 접근 상태 유지

> 이 방식은 성능에 부담이 크지만, 하드웨어 한계를 소프트웨어로 극복한 사례

---

## ✅ 요약

VAX/VMS 가상 메모리 시스템은 하드웨어의 한계에도 불구하고, 운영체제 설계로 이를 극복한 대표적인 사례다.

| 구성 요소 | 역할 |
|------------|--------------------------------------------------|
| 세그멘트 | P0(코드/힙), P1(스택), S(커널) |
| 페이징 | 고정 크기 페이지로 물리 메모리 가상화 |
| 페이지 교체 | Segmented FIFO + Second-Chance List |
| 클러스터링 | 스왑 효율 향상 |
| Demand Zeroing | 사용 시점에만 0으로 초기화 |
| Copy-on-Write | 메모리 절약 및 fork 최적화 |
| Ref Bit 에뮬레이션 | 보호 비트로 접근 추적 |

이 시스템의 설계 철학은 오늘날 Linux, Windows 등 현대 운영체제에서도 그대로 이어지고 있다.

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
