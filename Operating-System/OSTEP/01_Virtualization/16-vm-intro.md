# 🧠 주소 공간의 개념 (OSTEP Chapter 16)

이 장에서는 메모리를 어떻게 "가상화"하는지의 근본적인 철학과 개념을 다룬다.  
즉, 실행 중인 프로그램이 물리 메모리를 직접 다루는 것이 아니라, 운영체제가 제공하는 **주소 공간(Address Space)**이라는 "가상의 메모리 세계" 안에서 실행되는 방식이다.

---

## ❓ 핵심 질문

> 운영체제는 어떻게 해서 프로그램에게 **물리 메모리가 아닌 "자기만의 주소 공간"**을 주는 환상을 제공할 수 있을까?

---

## 🔍 상세 개념 정리

### 16.1 초기 시스템: 단순한 현실

- 초창기 컴퓨터 시스템은 **운영체제와 단 하나의 사용자 프로그램만 메모리에 적재**.
- 운영체제는 물리 주소 0부터 상주, 사용자 프로그램은 뒤쪽(예: 64KB 이후)부터 적재됨.
- **가상 메모리(VM)** 개념 자체가 존재하지 않았고, 사용자는 **운영체제와 직접 메모리를 공유**.

> 💬 당시에는 성능보다 단순한 실행이 중요했고, 사용자의 기대치도 낮았음.

---

### 16.2 멀티프로그래밍과 시분할의 등장

- 컴퓨터가 고가 장비가 되면서 **여러 명이 동시에 사용**하는 필요성 대두 → 멀티프로그래밍
- I/O 중인 프로세스를 대기시키고, 다른 프로세스를 실행시켜 **CPU 효율 극대화**
- 곧 **시분할(Time-Sharing)** 개념 등장: 다수 사용자가 **즉각적인 응답(Interactivity)** 을 요구

#### ❌ 초창기 시분할의 한계
- 프로세스 간 전환 시 **전체 메모리 상태를 디스크에 저장** → 매우 느림
- 해결책: **모든 프로세스를 메모리에 동시에 유지** + 운영체제가 상태만 전환

---

### 16.3 주소 공간: 환상의 핵심

운영체제는 각 프로세스에게 **자기만의 독립적인 주소 공간**을 제공함으로써 메모리 가상화를 구현한다.

#### 🧩 주소 공간의 구성

| 구성 요소 | 설명 |
|-----------|------|
| 코드(Code) | 프로그램 명령어 |
| 힙(Heap) | 동적 메모리 영역 (malloc 등) |
| 스택(Stack) | 함수 호출, 지역 변수 등 |

#### 📌 주소 공간 배치 예시

```text
0x00000000  ← 코드 (정적)
   ↓
0x00001000  ← 힙 (아래로 확장)
       ...
0x0000F000  ← 스택 (위로 확장)
0x00010000
```

> 💡 실제 물리 메모리에선 이런 식으로 정렬되지 않음.  
> 이 구조는 **프로세스가 "자기만의 완전한 컴퓨터를 갖고 있는 것처럼 보이게 함**.

---

### 16.4 왜 주소 공간이 중요한가?

운영체제는 다음 세 가지 목표를 달성하기 위해 주소 공간을 제공한다:

#### 🎯 1. 투명성 (Transparency)

- **프로그램은 물리 메모리 위치를 모른다.** 오직 가상 주소만 사용
- 마치 자신만의 전용 메모리를 갖고 있는 것처럼 착각함
- 예를 들어, 포인터를 출력해 보면 그 값은 전부 **가상 주소**

```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    printf("code  : %p\n", (void *) main);
    printf("heap  : %p\n", malloc(1));
    int x = 3;
    printf("stack : %p\n", (void *) &x);
    return 0;
}
```

> 실행 시 나오는 모든 주소는 **물리 주소가 아닌 가상 주소**임.

#### 🎯 2. 효율성 (Efficiency)

- 운영체제는 가상화 기법을 통해 메모리를 **효율적으로 사용**해야 함
- 너무 많은 오버헤드를 유발하거나 메모리 공간 낭비가 커져선 안 됨
- 하드웨어 지원 (예: **TLB**, 페이지 테이블 등) 필요함

#### 🎯 3. 보호 (Protection)

- 하나의 프로세스가 **다른 프로세스의 주소 공간을 침범하거나 읽는 것을 방지**
- 운영체제 자체도 사용자 코드로부터 보호됨
- 이를 통해 **고립(isolation)** 및 **안정성** 확보

---

### 📖 여담: 모든 주소는 가상 주소다

> 프로그램에서 보는 주소는 모두 "가상"이다.  
> 물리 주소는 운영체제와 하드웨어만이 알고 있다.

- malloc으로 할당된 주소, 지역 변수 주소, main 함수 주소 모두 **가상 주소**
- 운영체제는 이를 물리 주소로 변환하여 실제 메모리에 접근

---

## ✅ 요약

- 운영체제는 **주소 공간**이라는 개념을 통해, 각 프로세스가 **자신만의 독립적 메모리 환경**을 가지는 것처럼 만들어준다.
- 이 주소 공간은 코드, 힙, 스택 등으로 구성되며, 가상 주소는 물리 주소와 완전히 분리된다.
- 가상 메모리 시스템은 다음 세 가지 목표를 달성해야 한다:
  1. **투명성**: 프로그램은 가상 메모리라는 사실을 인식하지 않음
  2. **효율성**: 자원을 낭비하지 않고 빠르게 동작해야 함
  3. **보호**: 서로의 침해 없이 안전하게 실행되어야 함
- 이 모든 환상은 **운영체제와 하드웨어가 협력하여 만들어낸 결과물**이다.

---

> 📚 출처: 『운영체제: 아주 쉬운 세 가지 이야기 (OSTEP)』
